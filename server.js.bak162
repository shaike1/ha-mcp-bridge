const express = require('express');
const crypto = require('crypto');
const { URL } = require('url');

const app = express();
const PORT = process.env.PORT || 3001;
const HA_URL = process.env.HOME_ASSISTANT_URL;
const HA_TOKEN = process.env.HOME_ASSISTANT_TOKEN;
const MCP_API_KEY = process.env.MCP_API_KEY;
const SERVER_URL = process.env.SERVER_URL || 'https://ha-mcp.right-api.com';

const clients = new Map();
const tokens = new Map();
const codes = new Map();

console.log('ğŸ  Home Assistant MCP Server - Claude.ai Remote Compatible');

// Middleware
app.use((req, res, next) => {
    console.log(`ğŸ“¥ ${req.method} ${req.path}`);
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS, PUT, DELETE');
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization, x-requested-with');
    res.setHeader('Cache-Control', 'no-cache');
    
    if (req.method === 'OPTIONS') {
        return res.status(200).end();
    }
    next();
});

app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true }));

// Utility functions
function base64URLEncode(str) {
    return str.toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
}

function sha256(buffer) {
    return crypto.createHash('sha256').update(buffer).digest();
}

function authenticateBearer(req, res, next) {
    const authHeader = req.headers.authorization;
    const token = authHeader?.replace('Bearer ', '');
    
    if (token === MCP_API_KEY || tokens.has(token)) {
        req.authType = token === MCP_API_KEY ? 'bearer' : 'oauth';
        req.tokenData = tokens.get(token);
        return next();
    }
    
    console.log('âŒ Authentication failed for token:', token ? token.substring(0, 8) + '...' : 'none');
    return res.status(401).json({ 
        error: 'invalid_token',
        error_description: 'Authentication required' 
    });
}

// MCP Tools Definition - Strict schema for Claude.ai
const MCP_TOOLS = [
    {
        name: 'get_entities',
        description: 'Get Home Assistant entities (lights, switches, sensors, etc.)',
        inputSchema: {
            type: 'object',
            properties: {
                domain: { 
                    type: 'string', 
                    description: 'Filter by entity domain (e.g., "light", "switch", "sensor")',
                    enum: ['light', 'switch', 'sensor', 'climate', 'cover', 'lock', 'fan', 'media_player']
                }
            },
            additionalProperties: false
        }
    },
    {
        name: 'call_service',
        description: 'Control Home Assistant devices by calling services',
        inputSchema: {
            type: 'object',
            properties: {
                domain: { 
                    type: 'string', 
                    description: 'Service domain (e.g., "light", "switch")',
                    enum: ['light', 'switch', 'climate', 'cover', 'lock', 'fan', 'media_player', 'script', 'automation']
                },
                service: { 
                    type: 'string', 
                    description: 'Service name (e.g., "turn_on", "turn_off", "toggle")',
                    enum: ['turn_on', 'turn_off', 'toggle', 'set_temperature', 'open_cover', 'close_cover']
                },
                entity_id: { 
                    type: 'string', 
                    description: 'Target entity ID (e.g., "light.living_room")'
                },
                data: { 
                    type: 'object', 
                    description: 'Additional service parameters (brightness, color, etc.)',
                    properties: {
                        brightness: { type: 'number', minimum: 0, maximum: 255 },
                        rgb_color: { type: 'array', items: { type: 'number' }, minItems: 3, maxItems: 3 },
                        color_temp: { type: 'number' },
                        temperature: { type: 'number' }
                    },
                    additionalProperties: true
                }
            },
            required: ['domain', 'service'],
            additionalProperties: false
        }
    }
];

// MCP Protocol Handler
async function handleMCPRequest(req, res) {
    const { method, params, id } = req.body;
    const requestId = id || crypto.randomUUID();
    
    console.log(`ğŸ”§ MCP Request: ${method}`, params ? JSON.stringify(params) : '');
    
    try {
        let result = null;
        
        switch (method) {
            case 'initialize':
                result = {
                    protocolVersion: "2024-11-05",
                    capabilities: {
                        tools: { listChanged: true },
                        resources: {},
                        prompts: {},
                        logging: {}
                    },
                    serverInfo: {
                        name: "Home Assistant MCP",
                        version: "1.0.0"
                    }
                };
                console.log('âœ… MCP Protocol initialized');
                break;
                
            case 'notifications/initialized':
                result = {};
                console.log('âœ… Client initialization notification received');
                break;
                
            case 'tools/list':
                result = { tools: MCP_TOOLS };
                console.log(`âœ… Tools listed: ${MCP_TOOLS.length} tools`);
                break;
                
            case 'tools/call':
                const { name, arguments: args } = params;
                console.log(`ğŸ› ï¸  Tool execution: ${name}`, args);
                
                if (name === 'get_entities') {
                    const entities = await getEntities(args?.domain);
                    result = {
                        content: [{
                            type: "text",
                            text: entities
                        }]
                    };
                } else if (name === 'call_service') {
                    const serviceResult = await callService(args.domain, args.service, args.entity_id, args.data);
                    result = {
                        content: [{
                            type: "text", 
                            text: serviceResult
                        }]
                    };
                } else {
                    throw new Error(`Unknown tool: ${name}`);
                }
                break;
                
            case 'resources/list':
                result = { resources: [] };
                break;
                
            case 'prompts/list':
                result = { prompts: [] };
                break;
                
            default:
                console.log(`â“ Unhandled method: ${method}`);
                result = {};
        }
        
        const response = { 
            jsonrpc: "2.0", 
            id: requestId, 
            result: result 
        };
        
        console.log(`ğŸ“¤ MCP Response: ${method} completed`);
        res.json(response);
        
    } catch (error) {
        console.error(`âŒ MCP Error [${method}]:`, error.message);
        const errorResponse = {
            jsonrpc: "2.0",
            id: requestId,
            error: {
                code: -32603,
                message: error.message,
                data: { method: method, timestamp: new Date().toISOString() }
            }
        };
        res.json(errorResponse);
    }
}

// MCP Discovery Endpoint - Enhanced for Claude.ai
app.get('/.well-known/mcp', (req, res) => {
    console.log('ğŸ” MCP Discovery endpoint accessed');
    
    const discoveryInfo = {
        version: "2024-11-05",
        name: "Home Assistant MCP",
        description: "Control and monitor your Home Assistant smart home devices through natural language",
        tools: MCP_TOOLS,
        resources: [],
        prompts: [],
        capabilities: {
            tools: { listChanged: true },
            resources: {},
            prompts: {},
            logging: {}
        },
        oauth: {
            issuer: SERVER_URL,
            authorization_endpoint: `${SERVER_URL}/oauth/authorize`,
            token_endpoint: `${SERVER_URL}/oauth/token`,
            registration_endpoint: `${SERVER_URL}/oauth/register`,
            scopes_supported: ["homeassistant:read", "homeassistant:write"],
            response_types_supported: ["code"],
            grant_types_supported: ["authorization_code"],
            code_challenge_methods_supported: ["S256", "plain"],
            token_endpoint_auth_methods_supported: ["client_secret_post", "none"]
        }
    };
    
    res.json(discoveryInfo);
});

// OAuth Discovery
app.get('/.well-known/oauth-authorization-server', (req, res) => {
    res.json({
        issuer: SERVER_URL,
        authorization_endpoint: `${SERVER_URL}/oauth/authorize`,
        token_endpoint: `${SERVER_URL}/oauth/token`,
        registration_endpoint: `${SERVER_URL}/oauth/register`,
        response_types_supported: ["code"],
        grant_types_supported: ["authorization_code"],
        code_challenge_methods_supported: ["S256", "plain"],
        token_endpoint_auth_methods_supported: ["client_secret_post", "none"]
    });
});

// OAuth Endpoints
app.post('/oauth/register', (req, res) => {
    const { redirect_uris, client_name, grant_types } = req.body;
    
    const clientId = `claude_${crypto.randomUUID()}`;
    const clientSecret = crypto.randomBytes(32).toString('hex');
    
    const client = {
        client_id: clientId,
        client_secret: clientSecret,
        redirect_uris: redirect_uris || [`${SERVER_URL}/oauth/callback`],
        client_name: client_name || 'Claude MCP Client',
        grant_types: grant_types || ['authorization_code']
    };
    
    clients.set(clientId, client);
    console.log('âœ… OAuth client registered:', clientId);
    
    res.json({
        client_id: clientId,
        client_secret: clientSecret,
        redirect_uris: client.redirect_uris,
        grant_types: client.grant_types
    });
});

app.get('/oauth/authorize', (req, res) => {
    const { 
        client_id, 
        redirect_uri, 
        scope, 
        state, 
        code_challenge, 
        code_challenge_method,
        response_type 
    } = req.query;
    
    console.log('ğŸ” OAuth authorization request:', { client_id, redirect_uri, scope });
    
    // Validate parameters
    if (response_type !== 'code') {
        return res.status(400).json({ 
            error: 'unsupported_response_type',
            error_description: 'Only "code" response type is supported'
        });
    }
    
    // Auto-register client if needed (for Claude.ai compatibility)
    if (!clients.has(client_id)) {
        const autoClient = {
            client_id,
            client_secret: crypto.randomBytes(32).toString('hex'),
            redirect_uris: [redirect_uri],
            client_name: 'Auto-registered Claude Client'
        };
        clients.set(client_id, autoClient);
        console.log('âœ… Auto-registered client:', client_id);
    }
    
    // Generate authorization code
    const authCode = crypto.randomBytes(16).toString('hex');
    codes.set(authCode, {
        client_id,
        scope: scope || 'homeassistant:read homeassistant:write',
        redirect_uri,
        code_challenge,
        code_challenge_method,
        expires: Date.now() + 600000, // 10 minutes
        used: false
    });
    
    console.log('âœ… Authorization code generated');
    
    // For automatic approval (since this is your own server)
    const callbackUrl = new URL(redirect_uri);
    callbackUrl.searchParams.set('code', authCode);
    if (state) callbackUrl.searchParams.set('state', state);
    
    console.log('ğŸ”„ Redirecting to:', callbackUrl.toString());
    res.redirect(callbackUrl.toString());
});

app.post('/oauth/token', (req, res) => {
    const { grant_type, code, client_id, client_secret, code_verifier } = req.body;
    
    console.log('ğŸ« Token exchange request:', { grant_type, client_id });
    
    if (grant_type !== 'authorization_code') {
        return res.status(400).json({ 
            error: 'unsupported_grant_type',
            error_description: 'Only authorization_code grant type is supported'
        });
    }
    
    const codeData = codes.get(code);
    if (!codeData || codeData.used || codeData.expires < Date.now()) {
        console.log('âŒ Invalid authorization code');
        return res.status(400).json({ 
            error: 'invalid_grant',
            error_description: 'Authorization code is invalid or expired'
        });
    }
    
    // Verify PKCE if provided
    if (codeData.code_challenge && code_verifier) {
        const challengeFromVerifier = base64URLEncode(sha256(code_verifier));
        if (challengeFromVerifier !== codeData.code_challenge) {
            console.log('âŒ PKCE verification failed');
            return res.status(400).json({ 
                error: 'invalid_grant',
                error_description: 'PKCE verification failed'
            });
        }
        console.log('âœ… PKCE verification passed');
    }
    
    // Mark code as used
    codeData.used = true;
    
    // Generate access token
    const accessToken = crypto.randomBytes(32).toString('hex');
    const tokenData = {
        client_id: codeData.client_id,
        scope: codeData.scope,
        expires: Date.now() + 3600000 // 1 hour
    };
    
    tokens.set(accessToken, tokenData);
    codes.delete(code);
    
    console.log('ğŸ‰ Access token generated successfully');
    
    const tokenResponse = {
        access_token: accessToken,
        token_type: 'Bearer',
        expires_in: 3600,
        scope: codeData.scope
    };
    
    res.json(tokenResponse);
});

// Main MCP endpoints
app.get('/', (req, res) => {
    res.json({
        message: "Home Assistant MCP Server",
        version: "1.0.0",
        endpoints: {
            discovery: "/.well-known/mcp",
            oauth: "/oauth/authorize",
            rpc: "/rpc"
        }
    });
});

app.post('/rpc', authenticateBearer, handleMCPRequest);
app.post('/', authenticateBearer, handleMCPRequest);

// Health check
app.get('/health', (req, res) => {
    res.json({ 
        status: 'healthy',
        timestamp: new Date().toISOString(),
        homeAssistant: HA_URL ? 'configured' : 'not configured'
    });
});

// Home Assistant API Functions
async function getEntities(domain = null) {
    try {
        if (!HA_URL || !HA_TOKEN) {
            throw new Error('Home Assistant URL or token not configured');
        }
        
        const url = `${HA_URL}/api/states`;
        const response = await fetch(url, {
            headers: {
                'Authorization': `Bearer ${HA_TOKEN}`,
                'Content-Type': 'application/json'
            }
        });
        
        if (!response.ok) {
            throw new Error(`Home Assistant API error: ${response.status} ${response.statusText}`);
        }
        
        const entities = await response.json();
        let filtered = entities;
        
        if (domain) {
            filtered = entities.filter(e => e.entity_id.startsWith(domain + '.'));
        }
        
        console.log(`ğŸ“Š Retrieved ${filtered.length} entities${domain ? ` for domain: ${domain}` : ''}`);
        
        // Format for better readability
        const formattedEntities = filtered.slice(0, 25).map(entity => ({
            entity_id: entity.entity_id,
            name: entity.attributes?.friendly_name || entity.entity_id,
            state: entity.state,
            domain: entity.entity_id.split('.')[0],
            last_changed: entity.last_changed
        }));
        
        return JSON.stringify({
            success: true,
            total_count: filtered.length,
            returned_count: formattedEntities.length,
            entities: formattedEntities
        }, null, 2);
        
    } catch (error) {
        console.error('âŒ Get entities error:', error.message);
        return JSON.stringify({
            success: false,
            error: error.message
        }, null, 2);
    }
}

async function callService(domain, service, entity_id, data = {}) {
    try {
        if (!HA_URL || !HA_TOKEN) {
            throw new Error('Home Assistant URL or token not configured');
        }
        
        const url = `${HA_URL}/api/services/${domain}/${service}`;
        const requestBody = { ...data };
        if (entity_id) requestBody.entity_id = entity_id;
        
        console.log(`ğŸ¯ Calling service: ${domain}.${service} on ${entity_id || 'no target'}`);
        
        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${HA_TOKEN}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(requestBody)
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Service call failed: ${response.status} ${response.statusText} - ${errorText}`);
        }
        
        const result = await response.json();
        console.log(`âœ… Service executed successfully: ${domain}.${service}`);
        
        return JSON.stringify({
            success: true,
            service: `${domain}.${service}`,
            target_entity: entity_id || 'none',
            data_sent: requestBody,
            result: result
        }, null, 2);
        
    } catch (error) {
        console.error('âŒ Service call error:', error.message);
        return JSON.stringify({
            success: false,
            error: error.message,
            service: `${domain}.${service}`,
            target_entity: entity_id || 'none'
        }, null, 2);
    }
}

// Server startup
app.listen(PORT, '0.0.0.0', () => {
    console.log('ğŸš€ Home Assistant MCP Server Started');
    console.log(`ğŸ“ Server URL: ${SERVER_URL}`);
    console.log(`ğŸ” Discovery: ${SERVER_URL}/.well-known/mcp`);
    console.log(`ğŸ” OAuth: ${SERVER_URL}/oauth/authorize`);
    console.log(`ğŸ› ï¸  Tools: ${MCP_TOOLS.map(t => t.name).join(', ')}`);
    console.log(`ğŸ  Home Assistant: ${HA_URL || 'NOT CONFIGURED'}`);
    console.log('');
    console.log('ğŸ“‹ Environment Variables:');
    console.log(`   HOME_ASSISTANT_URL: ${HA_URL ? 'âœ… Set' : 'âŒ Missing'}`);
    console.log(`   HOME_ASSISTANT_TOKEN: ${HA_TOKEN ? 'âœ… Set' : 'âŒ Missing'}`);
    console.log(`   SERVER_URL: ${SERVER_URL}`);
    console.log('');
    console.log('ğŸ”§ Ready for Claude.ai integration!');
});
